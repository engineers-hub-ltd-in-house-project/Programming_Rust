# エコーサーバーサンプル

このサンプルは『Programming Rust』第2版の第18章「入出力」の「ネットワーキング」セクションで紹介されているシンプルなTCPエコーサーバーの実装です。

## 概要

このプログラムは、指定されたポートでTCP接続をリッスンし、クライアントからの接続を受け付けます。接続が確立されると、クライアントから送信されたデータをそのままクライアントに送り返す「エコー」機能を提供します。

## 学べる概念

- TCP/IPネットワークプログラミング
- 標準ライブラリの`std::net`モジュールの使用
- マルチスレッドによる複数クライアントの同時処理
- I/Oストリームの読み書き
- エラー処理とリソース管理
- スレッド間の同期

## 主要コンポーネント

### `main`関数

サーバーのエントリーポイントとなる関数です。指定されたアドレスでTCPリスナーを作成し、クライアント接続を受け付けるループを実行します。

### `handle_client`関数

クライアントとの通信を処理する関数です。クライアントからのデータを読み取り、同じデータを送り返します。

```rust
fn handle_client(mut stream: TcpStream) -> Result<(), Error> {
    let mut buffer = [0u8; 1024]; // 1KBのバッファ
    
    loop {
        let bytes_read = stream.read(&mut buffer)?;
        if bytes_read == 0 {
            // クライアントが接続を閉じた
            return Ok(());
        }
        
        // 読み取ったデータをそのまま送り返す
        stream.write_all(&buffer[..bytes_read])?;
    }
}
```

## 実行方法

```bash
# ビルド
cargo build

# 実行（デフォルトでは127.0.0.1:8000でリッスン）
cargo run

# または特定のアドレスとポートを指定
cargo run -- 127.0.0.1:9000
```

サーバー起動後、別のターミナルから`telnet`や`netcat`などのツールを使って接続テストができます：

```bash
# telnetを使用
telnet localhost 8000

# または netcatを使用
nc localhost 8000
```

接続後、キーボードから入力したテキストがそのままエコーされて戻ってくるはずです。

## 学習ポイント

1. **TCPソケットプログラミング**: `TcpListener`と`TcpStream`を使ったソケットプログラミングの基本を学べます。

2. **マルチスレッド処理**: 各クライアント接続を別々のスレッドで処理することで、複数のクライアントを同時にサポートする方法を示しています。

3. **I/Oエラーハンドリング**: ネットワーク操作中に発生する可能性のあるエラーを適切に処理する方法を学べます。

4. **バイナリデータの送受信**: バイト配列を使用してバイナリデータを送受信する方法を示しています。

5. **リソース管理**: スレッドの生成と管理、接続のクローズなど、リソースを適切に管理する方法を学べます。

## 発展課題

1. 非同期I/Oを使用して、スレッドプールなしで多数の接続を処理する版を実装する（`tokio`や`async-std`を使用）
2. バッファサイズを動的に調整する機能を追加する
3. タイムアウト処理を追加して、一定時間アイドル状態の接続を切断する
4. 簡単なコマンドを認識して実行する機能を追加する（例：`HELP`、`QUIT`など）
5. TLSを使用してセキュアな接続をサポートする
6. 接続数やデータ転送量などの統計情報を記録・表示する機能を追加する 
