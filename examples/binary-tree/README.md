# 二分木サンプル

このサンプルは『Programming Rust』第2版の第10章「列挙型とパターン」および第15章「イテレータ」で紹介されている二分木データ構造の実装例です。

## 概要

このライブラリは、ジェネリックな二分木データ構造（`BinaryTree<T>`）を実装しています。また、第15章では、この二分木に対するイテレータの実装方法を示しています。

## 学べる概念

- ジェネリック型を使用した再帰的データ構造
- 列挙型とパターンマッチング
- `Box<T>`を使用したヒープ上のデータ管理
- カスタムイテレータの実装
- トレイトの実装と利用
- テストコードの書き方

## 主要コンポーネント

### `BinaryTree<T>` 列挙型

二分木の構造を表す列挙型で、空のノードまたは値を持つノードのいずれかです。

```rust
enum BinaryTree<T> {
    Empty,
    NonEmpty(Box<TreeNode<T>>),
}
```

### `TreeNode<T>` 構造体

二分木のノードを表す構造体で、要素の値と左右の子ノードを持ちます。

```rust
struct TreeNode<T> {
    element: T,
    left: BinaryTree<T>,
    right: BinaryTree<T>,
}
```

### イテレータ実装

中順走査（in-order traversal）で木を巡回するイテレータです。

```rust
struct TreeIter<'a, T> {
    unvisited: Vec<&'a TreeNode<T>>
}

impl<'a, T: 'a> Iterator for TreeIter<'a, T> {
    type Item = &'a T;
    fn next(&mut self) -> Option<&'a T> {
        // 実装の詳細...
    }
}
```

## 使用方法

```rust
// 空の二分木を作成
let mut tree = BinaryTree::Empty;

// 値を追加
tree.add("apple");
tree.add("banana");
tree.add("cherry");

// イテレータを使って値を取得
for fruit in &tree {
    println!("{}", fruit);
}

// 値のベクトルとして取得
let fruits = tree.walk();
assert_eq!(fruits, vec!["apple", "banana", "cherry"]);
```

## 学習ポイント

1. **再帰的データ構造**: 二分木は自分自身を参照する再帰的な構造を持ちます。これをRustでどのように実装するかを学べます。

2. **ボックス型の使用**: 再帰的データ構造を実装するために、`Box<T>`を使用してヒープ上にデータを確保する方法を学べます。

3. **ジェネリックプログラミング**: 型パラメータ`T`を使用して、任意の型のデータを格納できる汎用的な構造を実装しています。

4. **トレイト境界**: `T: Ord`や`T: Clone`など、型パラメータに制約を付けることで、特定の機能を必要とする操作を実装しています。

5. **カスタムイテレータ**: `Iterator`トレイトを実装することで、for-in構文で木を巡回できるようにしています。これは、Rustのエコシステムとの統合の良い例です。

6. **所有権とライフタイム**: イテレータの実装では、所有権を移動せずに参照を使うため、ライフタイムパラメータ`'a`を使用しています。

## 発展課題

1. 二分探索木のバランス調整機能を追加する（AVL木やレッドブラック木を実装）
2. 前順走査（pre-order）や後順走査（post-order）のイテレータも実装する
3. 木の深さや要素数を計算するメソッドを追加する
4. 二分木を可視化する機能（テキストやグラフィカル）を実装する
5. ノードの削除操作を実装する 
